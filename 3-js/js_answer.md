# prepare_frontend_interview

## JavaScript

<b>프론트엔드 기술 면접을 위한 핸드북 만들기</b>

면접의 인터뷰어 분들이 JS의 수 많은 개념들을 순서대로 질문을 하지는 않습니다.

하지만 자바스크립트의 연관되어 있는 개념들을 순서대로 나열하고 핸드북 형식으로 보다 보면,

모르는 개념을 파악하고 한눈에 보는 것에 있어서 도움이 되지 않을까 싶어 제작하게 되었습니다.

목차는 모던 자바스크립트 deep dive를 기준으로 제작하였고 자세한 정리 내용은

[링크](https://github.com/junh0328/upgrade_javascript) 클릭 시에 해당 레포지토리에서 볼 수 있습니다.

질문에 대한 3-5줄 정도의 짧은 길이로 핵심 키워드를 체크하고 헷갈리는 용어들을 반복적으로 보게 됨으로써, 핵심 키워드를 기억할 수 있도록 만드는 것이 목표입니다!

## 목차

- [prepare\_frontend\_interview](#prepare_frontend_interview)
  - [JavaScript](#javascript)
  - [목차](#목차)
  - [프로그래밍](#프로그래밍)
    - [프로그래밍이란 뭐라고 생각하나요?](#프로그래밍이란-뭐라고-생각하나요)
    - [컴파일러는 뭐고 인터프리터는 뭔가요?](#컴파일러는-뭐고-인터프리터는-뭔가요)
  - [자바스크립트란](#자바스크립트란)
    - [자바스크립트의 특징은 뭐가 있나요?](#자바스크립트의-특징은-뭐가-있나요)
  - [변수](#변수)
    - [변수란 무엇인가요?](#변수란-무엇인가요)
    - [식별자는 무엇인가요?](#식별자는-무엇인가요)
    - [변수를 선언한다는 것은 어떤 것을 의미하나요?](#변수를-선언한다는-것은-어떤-것을-의미하나요)
    - [var 키워드는 뭔가요?](#var-키워드는-뭔가요)
    - [호이스팅이 뭔가요?](#호이스팅이-뭔가요)
    - [var 키워드의 문제점은 무엇이 있나요?](#var-키워드의-문제점은-무엇이-있나요)
    - [let 키워드는 var 키워드와 어떤 점이 다른가요?](#let-키워드는-var-키워드와-어떤-점이-다른가요)
    - [const 키워드는 어떤 특징이 있나요?](#const-키워드는-어떤-특징이-있나요)
    - [한 줄 요약](#한-줄-요약)
    - [식별자 네이밍 규칙은 어떤 것들이 있나요?](#식별자-네이밍-규칙은-어떤-것들이-있나요)
    - [네이밍 컨벤션은 어떤 것들이 있나요?](#네이밍-컨벤션은-어떤-것들이-있나요)
    - [리터럴이 뭔가요?](#리터럴이-뭔가요)
  - [데이터 타입](#데이터-타입)
    - [데이터 타입의 종류는 어떤 것들이 있나요?](#데이터-타입의-종류는-어떤-것들이-있나요)
    - [심벌 타입은 뭐죠?](#심벌-타입은-뭐죠)
    - [데이터 타입은 왜 필요할까요?](#데이터-타입은-왜-필요할까요)
    - [정적 타이핑이 뭔가요?](#정적-타이핑이-뭔가요)
    - [동적 타이핑이 뭔가요?](#동적-타이핑이-뭔가요)
  - [타입변환과 단축 평가](#타입변환과-단축-평가)
    - [명시적 타입 변환이 뭔가요?](#명시적-타입-변환이-뭔가요)
    - [명시적 타입 변환 함수를 예를 들어볼 수 있나요?](#명시적-타입-변환-함수를-예를-들어볼-수-있나요)
    - [암묵적 타입 변환이 뭔가요?](#암묵적-타입-변환이-뭔가요)
    - [truthy / falsy 한 값이 뭔가요?](#truthy--falsy-한-값이-뭔가요)
  - [배열](#배열)
    - [자바스크립트의 배열은 자료구조의 배열과 같나요?](#자바스크립트의-배열은-자료구조의-배열과-같나요)
    - [배열의 메서드는 어떤 종류가 있나요?](#배열의-메서드는-어떤-종류가-있나요)
    - [고차 함수에 대해서 아나요?](#고차-함수에-대해서-아나요)
    - [forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?](#foreach-메서드와-map메서드의-차이점에-대해-알고-있나요)
      - [forEach()](#foreach)
      - [map()](#map)
  - [객체 리터럴](#객체-리터럴)
    - [자바스크립트에서 객체란 뭘까요?](#자바스크립트에서-객체란-뭘까요)
    - [함수와 메서드의 차이점에 대해 알고 계신가요?](#함수와-메서드의-차이점에-대해-알고-계신가요)
    - [자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?](#자바스크립트에서-객체를-생성하는-방법은-어떤-것들이-있나요)
    - [전역 객체에 대해서 아나요?](#전역-객체에-대해서-아나요)
  - [원시 값과 객체 비교](#원시-값과-객체-비교)
    - [동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요?](#동적-타이핑을-지원하는-자바스크립트에서-데이터의-타입을-크게-2개로-나누는-이유가-있을까요)
    - [값에 의한 전달이 뭔가요?](#값에-의한-전달이-뭔가요)
    - [참조에 의한 전달이 뭔가요?](#참조에-의한-전달이-뭔가요)
  - [함수](#함수)
    - [자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?](#자바스크립트에서-함수를-정의하는-방법은-몇가지가-있나요)
    - [함수 선언문과 함수 표현식은 어떤 차이가 있나요?](#함수-선언문과-함수-표현식은-어떤-차이가-있나요)
    - [즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요](#즉시-실행-함수iife에-대해-알고-있나요-알고-있다면-아는-내용에-대해-말해보세요)
  - [스코프](#스코프)
    - [스코프가 뭔가요?](#스코프가-뭔가요)
    - [스코프에는 어떤 종류가 있죠?](#스코프에는-어떤-종류가-있죠)
    - [렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요?](#렉시컬-스코프를-아나요-안다면-렉시컬-스코프는-무엇을-의미하나요)
    - [전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?](#전역-변수로-변수를-선언하면-생기는-문제점은-무엇이-있을까요)
  - [생성자 함수에 의한 객체 생성](#생성자-함수에-의한-객체-생성)
    - [생성자 함수가 뭔가요?](#생성자-함수가-뭔가요)
    - [객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?](#객체-리터럴로-만들-때와는-무슨-차이가-있죠-왜-생성자-함수를-사용하나요)
    - [생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?](#생성자-함수가-객체인스턴스를-생성하는-과정에-대해-간략하게-설명해줄-수-있나요)
  - [함수와 일급 객체](#함수와-일급-객체)
    - [일급 객체가 뭔가요?](#일급-객체가-뭔가요)
    - [자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?](#자바스크립트에서-함수가-일급-객체라면-일급-객체로-뭘-할-수-있나요)
    - [꼬리 질문) 함수형 프로그래밍이 뭔가요?](#꼬리-질문-함수형-프로그래밍이-뭔가요)
    - [꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠?](#꼬리-질문-순수-함수가-뭔가요-일반-함수와는-어떤-차이가-있죠)
  - [프로토타입](#프로토타입)
    - [객체지향 프로그래밍은 무엇을 의미하나요?](#객체지향-프로그래밍은-무엇을-의미하나요)
    - [객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요?](#객체지향-프로그래밍의-특징에-대해-말해볼-수-있나요)
    - [자바스크립트는 객체지향 프로그래밍 언어인가요?](#자바스크립트는-객체지향-프로그래밍-언어인가요)
    - [프로토타입이 뭔가요?](#프로토타입이-뭔가요)
  - [strict mode](#strict-mode)
    - [strict mode가 뭔가요?](#strict-mode가-뭔가요)
    - [strict mode를 통해 무엇을 예방할 수 있죠?](#strict-mode를-통해-무엇을-예방할-수-있죠)
  - [빌트인 객체](#빌트인-객체)
    - [빌트인 객체가 뭔가요?](#빌트인-객체가-뭔가요)
    - [빌트인 객체의 종류는 어떤게 있죠?](#빌트인-객체의-종류는-어떤게-있죠)
    - [래퍼 객체에 대해서 알고 있나요?](#래퍼-객체에-대해서-알고-있나요)
  - [this](#this)
    - [this가 뭔가요?](#this가-뭔가요)
    - [this 바인딩이란?](#this-바인딩이란)
    - [this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?](#this는-동적으로-바인딩이-된다고-하는데-바인딩되는-객체가-어떻게-다르나요)
  - [실행 컨텍스트](#실행-컨텍스트)
    - [실행 컨텍스트에 대해 말해보세요](#실행-컨텍스트에-대해-말해보세요)
  - [클로저](#클로저)
    - [클로저에 대해서 아나요?](#클로저에-대해서-아나요)
    - [클로저를 사용하면 뭐가 좋죠?](#클로저를-사용하면-뭐가-좋죠)
    - [클로저를 어떻게 생성하나요?](#클로저를-어떻게-생성하나요)
    - [case 1 상위 스코프의 식별자를 참조하지 않는 경우](#case-1-상위-스코프의-식별자를-참조하지-않는-경우)
      - [디버깅](#디버깅)
    - [case 2 상위 스코프의 식별자를 참조하지만, 중첩 함수가 반환되지 않는 경우](#case-2-상위-스코프의-식별자를-참조하지만-중첩-함수가-반환되지-않는-경우)
      - [디버깅](#디버깅-1)
    - [case 3 상위 스코프의 식별자를 참조하고, 중첩 함수가 반환되는 경우 (올바르게 사용된 클로저)](#case-3-상위-스코프의-식별자를-참조하고-중첩-함수가-반환되는-경우-올바르게-사용된-클로저)
      - [디버깅](#디버깅-2)
      - [결과 보기](#결과-보기)
  - [클래스](#클래스)
    - [자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?](#자바스크립트에서-클래스가-생기기-전에는-어떤-방식으로-객체지향-패턴을-구현했나요)
    - [그럼 생성자 함수와 클래스는 어떤 차이가 있나요?](#그럼-생성자-함수와-클래스는-어떤-차이가-있나요)
    - [클래스 정의](#클래스-정의)
      - [익명 함수와 기명 함수로 클래스 정의](#익명-함수와-기명-함수로-클래스-정의)
      - [클래스 몸체에 정의할 수 있는 메서드](#클래스-몸체에-정의할-수-있는-메서드)
      - [정적 메서드와 프로토타입 메서드의 차이](#정적-메서드와-프로토타입-메서드의-차이)
    - [클래스의 상속](#클래스의-상속)
      - [extends 키워드](#extends-키워드)
    - [클래스 확장](#클래스-확장)
      - [super 키워드](#super-키워드)
      - [super 호출](#super-호출)
      - [super 참조](#super-참조)
      - [추상화](#추상화)
      - [오버라이딩](#오버라이딩)
      - [오버로딩](#오버로딩)
  - [스프레드 문법](#스프레드-문법)
    - [spread 문법이 뭔가요?](#spread-문법이-뭔가요)
    - [코드 요약](#코드-요약)
    - [어떤 상황에서 사용할 수 있죠?](#어떤-상황에서-사용할-수-있죠)
  - [구조 분해 할당](#구조-분해-할당)
    - [구조 분해 할당이 뭔가요?](#구조-분해-할당이-뭔가요)
    - [구조 분해 할당은 크게 어떤 종류가 있나요?](#구조-분해-할당은-크게-어떤-종류가-있나요)
  - [브라우저 렌더링 과정](#브라우저-렌더링-과정)
    - [브라우저의 렌더링 과정에 대해 설명해보세요](#브라우저의-렌더링-과정에-대해-설명해보세요)
    - [브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요?](#브라우저의-렌더링-과정에-자바스크립트는-어떻게-동작하나요)
    - [`<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까요?](#scriptscript-태그를-bodybody-태그-밑에-둬야하는-이유가-있을까요)
  - [DOM](#dom)
    - [DOM이 뭔가요?](#dom이-뭔가요)
    - [DOM을 구성하는 건 뭐가 있나요?](#dom을-구성하는-건-뭐가-있나요)
  - [이벤트](#이벤트)
    - [마우스 이벤트 타입에는 뭐가 있나요? click 말고 클릭을 대체할 수 있는 이벤트가 있나요?](#마우스-이벤트-타입에는-뭐가-있나요-click-말고-클릭을-대체할-수-있는-이벤트가-있나요)
    - [그 외에 알고 있는 대표적인 이벤트가 있나요?](#그-외에-알고-있는-대표적인-이벤트가-있나요)
    - [이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나요?](#이벤트-핸들러를-등록하는-방식에는-어떤-것들이-있나요)
    - [이벤트 전파(propagation)에 대해서 알고 있나요?](#이벤트-전파propagation에-대해서-알고-있나요)
    - [이벤트 위임(delegation)에 대해서 알고있나요?](#이벤트-위임delegation에-대해서-알고있나요)
    - [e.preventDefault 에 대해 알고 있나요?](#epreventdefault-에-대해-알고-있나요)
    - [e.stopPropagation](#estoppropagation)
  - [타이머](#타이머)
    - [호출 스케쥴링이 무엇인가요?](#호출-스케쥴링이-무엇인가요)
    - [타이머 함수에는 어떤 것들이 있나요?](#타이머-함수에는-어떤-것들이-있나요)
    - [이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?](#이벤트가-과도하게-호출되어-성능에-문제를-일으킬-경우에-할-수-있는-어떤-일을-통해-해결할-수-있나요)
    - [디바운스에 대해서 알고 있나요?](#디바운스에-대해서-알고-있나요)
    - [쓰로틀에 대해서 알고 있나요?](#쓰로틀에-대해서-알고-있나요)
  - [비동기 프로그래밍](#비동기-프로그래밍)
    - [동기와 비동기의 차이점에 대해서 설명해줄 수 있나요?](#동기와-비동기의-차이점에-대해서-설명해줄-수-있나요)
    - [이벤트 루프와 태스크 큐에 대해서 알고 있나요?](#이벤트-루프와-태스크-큐에-대해서-알고-있나요)
    - [다음과 같은 코드에서 이벤트 루프와 태스크 큐가 어떻게 동작하는지 설명해볼 수 있나요?](#다음과-같은-코드에서-이벤트-루프와-태스크-큐가-어떻게-동작하는지-설명해볼-수-있나요)
    - [마이크로태스크 큐에 대해서 알고 있나요?](#마이크로태스크-큐에-대해서-알고-있나요)
    - [태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요?](#태스크-큐와-마이크로태스크-큐-중-어떤-것이-먼저-실행되나요)
  - [Ajax](#ajax)
    - [Ajax가 뭔가요 어떤 것을 담당하고 있죠?](#ajax가-뭔가요-어떤-것을-담당하고-있죠)
    - [Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?](#ajax를-사용하면-기존-방식과-어떤-차이가-있을까요)
    - [JSON 이 뭔가요?](#json-이-뭔가요)
    - [JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나요?](#json이-제공하는-정적-프로토타입-메서드에-대해-몇가지-말해볼-수-있나요)
    - [Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나요?](#ajax로-http-요청을-보내기-위해서는-어떤-방법을-사용할-수-있나요)
    - [XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요?](#xmlhttprequest와-fetch-메서드의-차이는-무엇이라고-생각하시나요)
  - [REST API](#rest-api)
    - [REST API가 뭔가요?](#rest-api가-뭔가요)
    - [REST API의 구성은 어떤 것이 있나요?](#rest-api의-구성은-어떤-것이-있나요)
    - [REST API를 설계하는데 중요한 것이 있을까요?](#rest-api를-설계하는데-중요한-것이-있을까요)
    - [HTTP 요청 메서드에 대해서 아는대로 얘기해보세요](#http-요청-메서드에-대해서-아는대로-얘기해보세요)
    - [HTTP 상태 코드를 아는대로 말해주세요](#http-상태-코드를-아는대로-말해주세요)
  - [Promise](#promise)
    - [콜백이란 뭐라고 생각하나요?](#콜백이란-뭐라고-생각하나요)
    - [프로미스가 뭔가요?](#프로미스가-뭔가요)
    - [프로미스 생성 방법](#프로미스-생성-방법)
    - [프로미스의 상태를 나타내는 것은 어떤 것들이 있나요?](#프로미스의-상태를-나타내는-것은-어떤-것들이-있나요)
    - [프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요?](#프로미스-빌트인-객체가-제공하는-정적-메서드에-대해-알고-있나요)
  - [제너레이터와 async await](#제너레이터와-async-await)
    - [`제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?`](#제너레이터란-뭔가요-일반-함수와는-어떤-차이가-있죠)
    - [`제너레이터의 구조`](#제너레이터의-구조)
    - [`async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠?`](#asyncawait-가-뭔가요-기존의-promise와는-어떤-차이가-있죠)
    - [`Promise와 async/await의 차이점 한 줄 요약`](#promise와-asyncawait의-차이점-한-줄-요약)
  - [에러](#에러)
    - [`에러처리를 왜 해야 하나요?`](#에러처리를-왜-해야-하나요)
    - [`자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?`](#자바스크립트에서-에러를-처리하는-방법에는-뭐가-있을까요)
  - [모듈](#모듈)
    - [`모듈이 뭔가요?`](#모듈이-뭔가요)
  - [내가 뽑은 핵심질문 5개](#내가-뽑은-핵심질문-5개)
  - [스터디원이 뽑은 핵심질문](#스터디원이-뽑은-핵심질문)

## 프로그래밍

### 프로그래밍이란 뭐라고 생각하나요?
- 프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션입니다.

<br/>

### 컴파일러는 뭐고 인터프리터는 뭔가요?
- 컴파일러와 인터프리터는 프로그래밍 언어를 컴퓨터가 이해가능한 기계어로 변환하는 도구입니다. 컴파일러는 전체를 스캔하기에 인터프리터에 비해 번역 속도는 느리고 실행 속도는 빠릅니다.

<br/>

## 자바스크립트란

### 자바스크립트의 특징은 뭐가 있나요?
- 자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이자 인터프리터 언어입니다. 따라서 더욱 빠르게 코드가 실행가능합니다.

<br/>

## 변수

### 변수란 무엇인가요?
- 변할 수 있는 데이터라는 뜻으로 어떤 값이 담길 수 있는 메모리 공간 자체를 칭한 이름을 말합니다.

<br/>

### 식별자는 무엇인가요?
- 변수의 이름을 식별자라고도 하며, 메모리 상에 존재하는 값의 식별가능한 이름을 모두 식별자라고 부릅니다.

<br/>

### 변수를 선언한다는 것은 어떤 것을 의미하나요?

```js
let score;
```

- 변수 선언이란 **변수를 생성하는 것**으로, 해당 변수만을 위한 메모리 공간을 할당받는 행위입니다.

<br/>

### var 키워드는 뭔가요?
- var 키워드는 뒤에 오는 변수 이름을 새로운 변수로 선언할 것을 지시하는 일종의 명령어입니다. 변수를 선언한 이후, 값을 할당하지 않았을 땐 undefined라는 값이 암묵적으로 할당되어 초기화됩니다. 

<br/>

### 호이스팅이 뭔가요?
- 호이스팅이란 변수나 함수가 어디서 선언이 되던 최상단에 위치하게 되어 동일 스코프에선 어디서든 참조 가능한 것입니다.

<br/>

### var 키워드의 문제점은 무엇이 있나요?
- 변수의 중복 선언을 허용하고, 함수 레벨 스코프의 특성을 가지며, 실행 단계에서 실제 값이 할당되지 않더라도 undefined를 가지는 이를 변수 호이스팅이 일어난다.

<details>
<summary>① 변수 중복 선언 허용</summary>

var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되는데, 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

```js
function foo() {
  var x = 1;
  // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
  // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 2;
  console.log(x); // 2
}
foo();
```

</details>

<details>
<summary>② 함수 레벨 스코프</summary>

대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. 이러한 특성을 **블록 레벨 스코프**라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다. 이러한 특성을 **함수 레벨 스코프**라 한다.

```js
case 1 : var 키워드로 변수 선언

var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
  // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
  // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}
console.log(x); // 10


case 2 : var 키워드로 for문 안의 변수 선언

var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```

</details>

<details>
<summary>③ 변수 호이스팅</summary>

var 키워드로 선언된 변수는 선언과 동시에 undefined로 초기화되며, 런타임 즉 소스코드 평가 단계에서 스코프에 등록되기 때문에 실행 단계에서 실제 값이 할당되지 않더라도 undefined를 가지고있다. 이를 변수 호이스팅이라 한다.

```js
console.log(score); // undefined;

var score; // 변수 선언문
```

</details>

<br/>

### let 키워드는 var 키워드와 어떤 점이 다른가요?
- var와 달리 let 키워드는 변수 중복 선언이 불가능하며, 블록 레벨 스코프를 따르고, 변수 호이스팅이 일어나지 않습니다.

<br/>

### const 키워드는 어떤 특징이 있나요?
- const 키워드는 선언과 동시에 초기화해야 하며, 재할당이 불가하고, 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없습니다.

<br/>

### 한 줄 요약

|           var 키워드           | let 키워드  |     const 키워드     |
| :----------------------------: | :---------: | :------------------: |
| 선언 및 초기화 단계(undefined) |  선언 단계  | 선언 + 초기화 + 할당 |
|           할당 단계            | 초기화 단계 |                      |
|               -                |  할당 단계  |                      |

### 식별자 네이밍 규칙은 어떤 것들이 있나요?
- 식별자는 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있으며, 숫자로 시작하는 것은 허용하지 않습니다.

### 네이밍 컨벤션은 어떤 것들이 있나요?
- 대표적으로 카멜 케이스, 스네이크 케이스가 있습니다.

```js
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById("myId"); // DOM 노드
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

<br/>

### 리터럴이 뭔가요?
- 리터럴은 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기법을 말합니다.

<br/>

## 데이터 타입

### 데이터 타입의 종류는 어떤 것들이 있나요?

|   구분    |     데이터 타입     |                        설명                         |
| :-------: | :-----------------: | :-------------------------------------------------: |
| 원시 타입 |  숫자(number)타입   | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 원시 타입 | 문자열(string)타입  |                       문자열                        |
| 원시 타입 | 불리언(boolean)타입 |            논리적 참(true)과 거짓(false)            |
| 원시 타입 |    undefined타입    |  var 키워드로 선언된 변수에 암묵적으로 할당되는 값  |
| 원시 타입 |      null 타입      |  값이 없다는 것을 의도적으로 명시할 때 사용하는 값  |
| 원시 타입 |  심벌(symbol) 타입  |              ES6에서 추가된 7번째 타입              |
| 원시 타입 |     BigInt 타입     | 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형  |
| 객체 타입 |                     |                 객체, 함수, 배열 등                 |


<br/>

### 심벌 타입은 뭐죠?
- 심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능하고 다른 값과 중복되지 않는 원시 타입입니다. 따라서 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용합니다.

<br/>

### 데이터 타입은 왜 필요할까요?
1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

<br/>

### 정적 타이핑이 뭔가요?
- 변수 선언 시 할당 값의 타입을 사전에 명시적으로 선언하고 맞는 값을 할당하는 것입니다.

<br/>

### 동적 타이핑이 뭔가요?
- 자바스크립트는 동적 타입으로 변수의 타입 선언 없이 값이 할당되는 과정에서 동적으로 타입을 추론한다는 의미입니다.

<br/>

## 타입변환과 단축 평가

### 명시적 타입 변환이 뭔가요?
- 개발자가 의도적으로 값의 타입을 변환하는 것입니다.

<br/>

### 명시적 타입 변환 함수를 예를 들어볼 수 있나요?

1. String 생성자 함수를 new 연산자 없이 호출하는 방법
2. Object.prototype.toString 메서드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법

<br/>

### 암묵적 타입 변환이 뭔가요?
- 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환된느 것입니다.

<br/>

### truthy / falsy 한 값이 뭔가요?
- 불린 값으로 평가되어야 할 문맥에서 Truthy값은 true로, Falsy값은 false로 암묵적 타입 변환됩니다. Falsy 값의 예로는 false, undefinded, null 값 등이 있습니다.

아래 값들은 false로 평가되는 Falsy 값이다.

```js
false
undefined
null
0, -0
NaN
' '(빈 문자열)
```

Falsy값에 ! 연산자를 붙이면, 모두 Truthy 값으로 평가되어 실행 가능해진다.

```js
// 아래의 조건문은 모두 코드 블록을 실행한다.
if (!false) console.log(false + " is falsy value");
if (!undefined) console.log(undefined + " is falsy value");
if (!null) console.log(null + " is falsy value");
if (!0) console.log(0 + " is falsy value");
if (!NaN) console.log(NaN + " is falsy value");
if (!"") console.log("" + " is falsy value");
```

<br/>

## 배열

### 자바스크립트의 배열은 자료구조의 배열과 같나요?
- 다릅니다. 자바스크립트 배열은 요소의 각각의 메모리 공간은 크기가 동일하지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있는 특수한 객체입니다.

<br/>

### 배열의 메서드는 어떤 종류가 있나요?
- 원본 배열을 직접 변경하여 부수 효과를 발생시키는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있습니다.

<br/>

### 고차 함수에 대해서 아나요?
- 고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수로 가변 데이터를 피하고 불변성을 지향하므로 프로그래밍의 안정성을 높입니다.

<br/>

### forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?
- forEach 메서드는 단순히 반복문을 대체하기 위한 함수이고, map 메서드는 요소값을 다른 값으로 mapping한 새로운 배열을 생성하기 위한 고차함수입니다.

<br/>

#### forEach()

```js
// forEach 메서드는 콜백 함수를 호출하면서 3개(① 요소값 ② 인덱스 ③ this)의 인수를 전달한다.
[1, 2, 3].forEach((item, index, arr) => {
  console.log(`요소값: ${item}, 인덱스: ${index}, this: ${arr}`);
});

/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```

#### map()

```js
const numbers = [1, 4, 9];

// map 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
// 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.
const roots = numbers.map((item) => Math.sqrt(item));

// 위 코드는 다음과 같다.
// const roots = numbers.map(Math.sqrt);

// map 메서드는 새로운 배열을 반환한다
console.log(roots); // [ 1, 2, 3 ]
// map 메서드는 원본 배열을 변경하지 않는다
console.log(numbers); // [ 1, 4, 9 ]
```

`①forEach` 메서드와 `②map` 메서드의 공통점은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다는 것이다.

**하지만 `①forEach` 메서드는 언제나 undefined를 반환하고 `②map` 메서드는 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다는 것이다.**

즉 `forEach` 메서드는 **단순히 반복문을 대체하기 위한 고차 함수**이고 `Map` 메서드는 **요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차 함수**다.

map 메서드를 호출한 배열과 map 메서드가 생성하여 반환한 배열은 1:1 매핑한다.

forEach 메서드와 마찬가지로 map 메서드의 콜백 함수는 map 메서드를 호출한 배열의 요소값과 인덱스, map 메서드를 호출한 배열 자체, 즉 this를 순차적으로 받을 수 있다.

다시 말해, `① map` 메서드를 호출한 배열의 요소값 ② 인덱스 ③ 호출한 배열 자기 자신(this)를 순차적으로 전달한다.

<br/>

## 객체 리터럴

### 자바스크립트에서 객체란 뭘까요?
- 원시 값을 제외한 나머지 값은 모두 객체로, 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조 변경 가능한 값입니다. 

<br/>

### 함수와 메서드의 차이점에 대해 알고 계신가요?
- 함수는 특정 작업을 수행하기 위해 설계된 기능이고, 메서드는 객체의 프로퍼티가 함수인 경우입니다.

<br/>

### 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?
```
1.객체 리터럴
2.Object 생성자 함수
3.생성자 함수
4.Object.create 메서드
5.클래스(ES6)
```

<br/>

### 전역 객체에 대해서 아나요?
- 전역 객체는 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체입니다.

<br/>

## 원시 값과 객체 비교

### 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요?
- 변경가능한 값은 객체 타입값, 변경 불가능한 값은 원시 타입값으로 나누기 위해서입니다.

<br/>

### 값에 의한 전달이 뭔가요?
- 메모리에 값을 저장할때 값을 복사하여 메모리에 저장함을 의미합니다.

<br/>

### 참조에 의한 전달이 뭔가요?
- 메모리에 값을 저장할때 값이아닌 메모리의 주소를 저장함을 의마합니다.

<br/>

## 함수

### 자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?

1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수 (ES6)

```js
case 1 :함수 선언문

function add(x,y){
  return x+y;
}

case 2: 함수 표현식
var add = function(x,y){
  return x + y;
}

case 3: Function 생성자 함수
var add = new Function('x','y', 'return x+y');

case 4: 화살표 함수(ES6)
var add = (x,y) => x+y;
```

<br/>

### 함수 선언문과 함수 표현식은 어떤 차이가 있나요?
- 함수 선언문은 호이스팅에 의해 호출이 가능하지만, 함수 표현식은 undefined로 평가됩니다.

<br/>

### 즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요
- 함수 정의와 동시에 즉시 실행하는 함수로, 일회성이며 익명함수를 사용하며 이용합니다. 반드시 괄호로 감싸줘야 합니다.

<br/>

## 스코프

### 스코프가 뭔가요?
- 스코프는 유효 범위라는 뜻으로, 식별자(변수)가 유효한 범위를 말합니다.

<br/>

### 스코프에는 어떤 종류가 있죠?
- 전역 스코프와 지역 스코프로 나뉩니다. 전역이란 함수 전역을 의미하고, 지역이란 어떠한 함수의 내부 영역을 의미합니다.

<br/>

### 렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요?
- 함수를 어디서 호출했는지가 아니라 어디서 정의했는지에 따라 상위 스코프를 결정하는 것입니다. 

<br/>

### 전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?
- 어디서든 참조할 수 있는 변수가 생기므로 프로그래머가 의도치않은 동작이 생길 수 있다.(생명주기 길고, 스코프 체인 상 종점)

<br/>

## 생성자 함수에 의한 객체 생성

### 생성자 함수가 뭔가요?
- new 연산자와 함께 호출하여 객체를 생성하는 함수를 말하며, 생성자 함수로 의해 생성된 객체를 인스턴스라고 합니다.

<br/>

### 객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?
- 객체 리터럴로 만들면 단 하나의 객체만 생성하지만, 생성자 함수를 이용하면 반복적으로 프로퍼티 구조가 동일한 객체를 생성할 수 있습니다.

<br/>

### 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

1. 생성자 함수 선언
2. 인스턴스 생성
3. 인스턴스 초기화
4. 인스턴스 반환

```js
// 1. 생성자 함수 선언
function Circle(radius) {
  // 3. 인스턴스 초기화
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
  // 4. 인스턴스 생성시에 생성자 함수를 호출할 때 넣은 인수를 this 바인딩을 통해 프로퍼티에 할당한 뒤, 인스턴스를 반환한다
}
// 2. 인스턴스 생성
const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성
```

<br/>

## 함수와 일급 객체

### 일급 객체가 뭔가요?

다음과 같은 조건을 만족하는 **객체** 를 **일급 객체** 라 한다.

1. 무명의 리터럴로 생성할 수 있다. (함수 이름 없이)
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환 값으로 사용할 수 있다.

<br/>

### 자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?
- 일반 객체와 같이 함수의 매개변수에 전달가능하며, 함수의 반환값으로 사용할 수도 있습니다.

<br/>

### 꼬리 질문) 함수형 프로그래밍이 뭔가요?
- 외부 상태를 변경하지 않고, 의존하지도 않는 함수를 순수함수라 합니다. 이를 이용하여 안전성을 높이는 프로그래밍이 함수형 프로그래밍입니다.

<br/>

### 꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠?
- 순수 함수는 일반 함수와 달리 외부 상태에 의존하거나 변경하지 않는, 즉 부수 효과가 없는 함수입니다.

<br/>

## 프로토타입

### 객체지향 프로그래밍은 무엇을 의미하나요?
- 여러개의 객체를 독립적 집합으로 표현하여 프로그래밍하는 방식입니다.

<br/>

### 객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요?

1. 추상화 (Abstraciton)
2. 캡슐화 (Encapsulation)
3. 상속 (Inheritance)
4. 다형성 (Polymorphism)

<details>

<b>① 추상화</b>

- 객체를 구성할 수 있는 다양한 속성(프로퍼티) 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 추상화라 한다.

<b>② 캡슐화</b>

- 데이터 구조와 데이터를 다루는 방법들을 목적에 따라 결합 시켜 묶는 것. 다시 한번 말하자면 변수와 함수를 하나로 묶는것을 말한다.
- 또한 데이터를 절대로 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근해야하는데 이를 가능하게 해주는 것이 바로 캡슐화이다.

[출처](https://88240.tistory.com/228)

<b>③ 상속</b>

- 상위 개념의 특징을 하위 개념이 물려받는 것

<b>④ 다형성</b>

- 부모클레스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것

</details>

<br/>

### 자바스크립트는 객체지향 프로그래밍 언어인가요?
- 자바스크립트는 멀티패러다임 프로그래밍언어로, 명령형, 함수형, 객체지향 모두 지원합니다.
<br/>

### 프로토타입이 뭔가요?
- js에서 프로토타입은 상속을 위해 사용됩니다. 자바스크립트는 모두 객체로 이루어져있는데, 이중 가장 최상위 객체가 object입니다. object에서 파생시켜 다른 객체를 만들기 위해 사용하는 것이 프로토타입입니다.
  
<br/>

## strict mode

### strict mode가 뭔가요?
- ES5에 추가된 모드로 더 엄격한 문법을 적용해 오류 가능성이 있는 코드를 명시적으로 알려주는 것입니다.
  
<br/>

### strict mode를 통해 무엇을 예방할 수 있죠?

1. 암묵적 전역
2. 변수, 함수, 매개변수의 삭제
3. 매개변수 이름의 중복
   
<br/>

## 빌트인 객체

### 빌트인 객체가 뭔가요? 
- 개발자가 모든 기능을 구현하는 게 아닌, 자바스크립트에서 기본적으로 제공하는 객체입니다.
  
<br/>

### 빌트인 객체의 종류는 어떤게 있죠?

1. 표준 빌트인 객체
2. 호스트 객체
3. 사용자 정의 객체

<details>

<b>① 표준 빌트인 객체</b>

- 앞서 설명한 자바스크립트에서 기본적으로 제공하는 객체 중 ECMAScript 사양에 정의된 표준 객체. 애플리케이션 전역의 공통 기능을 제공합니다
- 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공됩니다. 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다
- new 연산자를 사용하여 표준 빌트인 객체와 결합하여 선언하면, 생성된 인스턴스로 하여금 해당 함수에 내장된(빌트인 된) 프로토타입 메서드들을 이용할 수 있다.

<b>② 호스트 객체</b>

- ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)에서 추가로 제공하는 객체를 말한다
- 브라우저 환경에서는 DOM, BOM, CANVAS, XMLHttpRequest, fetch, Web Storage, Web Component와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공합니다

<b>③ 사용자 정의 객체</b>

- 사용자 정의 객체는 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.

</details>

<br/>

### 래퍼 객체에 대해서 알고 있나요?
- wrapper로 원시타입을 객체타입으로 씌워서 마치 객체타입처럼 사용하는 과정 속에서 생기는 임시 객체입니다.

<br/>

## this

### this가 뭔가요?
- 자바스크립트에 의해 암묵적으로 생성되며, 자신이 속한 객체나 생성할 인스턴스를 가리키는 자기 참조 변수입니다.

<br/>

### this 바인딩이란?
- this와 this가 가리킬 객체를 연결하는 과정을 의미합니다.

<br/>

### this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?

| 함수 호출 방식                                             | this 바인딩                                                            |
| :--------------------------------------------------------- | :--------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체(window/ global)                                              |
| 콜백 함수 호출                                             | 전역 객체(window/ global)                                              |
| 내부 함수 호출                                             | 전역 객체(window/ global)                                              |
| 메서드 호출                                                | 메서드를 호출한 객체                                                   |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                                 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

<br/>

## 실행 컨텍스트

### 실행 컨텍스트에 대해 말해보세요
- 실행 컨텍스트는 소스코드를 실행하는데 필요한 환경을 제공하고, 코드의 실행 결과를 관리하느 영역입니다. 실행 컨텍스트 스택과 렉시컬 환경으로 구성되어 있습니다.

<br/>

## 클로저

### 클로저에 대해서 아나요?
- 클로저는 스코프를 이용해서 자신이 선언될 당시의 환경을 기억하는 함수의 현상입니다.

<br/>

### 클로저를 사용하면 뭐가 좋죠?
- 상태를 안전하게 변경하고 유지할 수 있습니다.

<br/>

### 클로저를 어떻게 생성하나요?

1. 내부(중첩) 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용될 때
2. 내부(중첩) 함수가 외부 함수의 스코프에서 실행될 때
3. 내부 함수에서 사용되는 변수가 외부 함수의 변수 스코프에 포함되어 있을 때

<br/>

### case 1 상위 스코프의 식별자를 참조하지 않는 경우

```html
<!DOCTYPE html>
<html>
  <body>
    <script>
      function foo() {
        const x = 1;
        const y = 2;

        function bar() {
          const z = 3;
          debugger;
          // 상위 스코프의 함수(foo)의 어떠한 식별자도 참조하지 않았다.
          console.log(z);
        }

        return bar;
      }

      const bar = foo();
      bar();
    </script>
  </body>
</html>
```

#### 디버깅

<img src="../images/closure1.png" alt="클로저x">

위 예제의 중첩 함수 bar는 외부 함수 foo 보다 더 오래 유지되지만 상위 스코프의 어떤 식별자(x,y)도 참조하지 않는다.

이처럼 상위 스코프의 어떤 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 다음 그림과 같이 상위 스코프를 기억하지 않는다.

참조하지도 않는 식별자를 기억하는 것은 메모리 낭비이기 때문이다. `따라서 bar 함수는 클로저라고 할 수 없다.`

```
참조하는 식별자를 실행 컨텍스트가 종료되어도 렉시컬 환경을 통해 참조하고, 값을 변경할 수 있는 것이 클로저이다.
```

<br/>

### case 2 상위 스코프의 식별자를 참조하지만, 중첩 함수가 반환되지 않는 경우

```html
<!DOCTYPE html>
<html>
  <body>
    <script>
      function foo() {
        const x = 1;

        // 일반적으로 클로저라고 하지 않는다.
        // bar 함수는 클로저였지만 곧바로 소멸한다.
        function bar() {
          debugger;
          // 상위 스코프의 식별자를 참조한다.
          console.log(x);
        }
        bar();
      }

      foo();
    </script>
  </body>
</html>
```

#### 디버깅

<img src="../images/closure2.png" alt="클로저x">

위 예제의 중첩 함수 bar는 상위 스코프의 식별자(x)를 참조하고 있으므로 클로저다.

하지만 외부 함수 foo의 외부로 중첩 함수가 반환되지 않는다.

즉, 외부 함수 foo보다 중첩 함수 bar의 생명 주기가 짧다. 이런 경우 중첩 함수 bar는 클로저였지만 외부 함수보다 일찍 소멸되기 때문에 생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있다든 클로저의 본질에 부합하지 않는다.

따라서 중첩 함수 bar는 일반적으로 클로저라고 하지 않는다.

<br/>

### case 3 상위 스코프의 식별자를 참조하고, 중첩 함수가 반환되는 경우 (올바르게 사용된 클로저)

```html
<!DOCTYPE html>
<html>
  <body>
    <script>
      function foo() {
        const x = 1;
        const y = 2;

        // 클로저
        // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
        function bar() {
          debugger;
          console.log(x);
        }
        return bar;
      }

      const bar = foo();
      bar();
    </script>
  </body>
</html>
```

#### 디버깅

<img src="../images/closure3.png" alt="클로저o">

위 예제의 `중첩 함수 bar는 상위 스코프의 식별자를 참고하고 있으므로 클로저다.`

그리고 외부 함수의 외부로 반환되어 외부 함수보다 더 오래 살아 남는다.

이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 `클로저` 라고 부른다.

클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

</details>

<br/>

<details>
<summary>함수형 프로그래밍에서의 클로저 사용하기</summary>

<br/>

```js
function closure() {
  let num = 10;

  function plusNum() {
    num += 1;
  }

  function printNum() {
    console.log(num);
  }

  function setNum(val) {
    num = val;
  }

  // 함수를 객체 형식으로 리턴하는 이유는 새로 생성한 변수를 (.) 연산자를 통해 (객체와 같은 방식으로) 접근하기 위해서
  // 함수뿐만 아니라 지역 변수도 리턴이 가능하다 (하지만 추천하지 않음)
  // 지역 변수를 객체 형식으로 담아서 리턴될 경우에, closure의 의도와 다르게 내부에 정의된 함수 외에도 지역 변수의 값을 변경하는 경우가 생기기 때문에
  // (객체는 가변성의 성질을 가지므로)

  return { num, plusNum, printNum, setNum };
}

// console.log("num is:", num); // num is not defined, 상위 스코프에서 하위 스코프로 식별자 검색을 할 수 없음

const newNum = closure(); // closure 함수로 newNum 함수를 생성한다.

console.log(newNum); // 생성된 함수객체 newNum은 closure 함수가 리턴하는 객체 형식의 프로퍼티와 메서드가 들어있음

console.log((newNum.num = 20)); // newNum.num 에 값을 할당 (closure 함수의 메서드를 사용하지 않고 직접 변경)
console.log(newNum); // 객체형식으로 리턴되는 newNum의 특성상 newNum의 프로퍼티인 num의 값이 재할당됨

newNum.printNum(); // 하지만 printNum 메서드를 사용하면 기존의 10 출력

newNum.setNum(100); // 따라서 지역 변수 num을 변경하기 위해서는 새로운 메서드를 정의하여 값을 전달함으로서 부수효과를 줄어야함

newNum.printNum(); // 100 출력

// 하지만 지역 변수를 리턴하더라도 원시 타입의 값은 불변성의 성질을 가지기 때문에, 재할당하지 않는 이상 값을 변화시킬 수 없다.
// 따라서 함수를 통해 반환하여 사용하는 것이 올바르다.
```

#### 결과 보기

```js
>> console.log(newNum)
{
  num: 10,
  plusNum: [Function: plusNum],
  printNum: [Function: printNum],
  setNum: [Function: setNum]
}

>> console.log((newNum.num = 20));
20

>> console.log(newNum);
{
  num: 20,
  plusNum: [Function: plusNum],
  printNum: [Function: printNum],
  setNum: [Function: setNum]
}

>> newNum.printNum();
10

>> newNum.setNum(100);

>> newNum.printNum();
100

```

</details>

## 클래스

### 자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?
- 생성자 함수와 프로토타입을 통해 객체지행 언의의 상속을 구현할 수 있었다.

<br/>

### 그럼 생성자 함수와 클래스는 어떤 차이가 있나요?

1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만, 생성자 함수는 일반 함수로 호출된다.

2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 생성자 함수는 해당 키워드를 제공하지 않는다.

3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 작성된 클래스는 함수 호이스팅이,
   함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.

4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 저장되어 실행되며 strict mode를 해제할 수 없다.
   <-> 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.

5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false인
   열거가 되지 않는 값이다.

### 클래스 정의

```js
// 클래스 선언문
class Person {}

// 함수 선언문으로 작성시, 함수 호이스팅이
// 함수 표현식으로 작성시, 변수 호이스팅이 발생한다.
```

#### 익명 함수와 기명 함수로 클래스 정의

```js
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

#### 클래스 몸체에 정의할 수 있는 메서드

- ① constructor(생성자)
- ② 프로토타입 메서드
- ③ 정적 메서드

```js
class Person {
  // constructor: 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드 (static을 붙여 정의한다)
  static sayHello() {
    console.log("Hello!");
  }
}

// 인스턴스 생성
const me = new Person("Lee");

// ① 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// ② 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// ③ 정적 메서드 호출 (호출 시에 인스턴스가 아닌 클래스의 메서드로 동작한다.)
Person.sayHello(); // Hello!
```

#### 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다. 🌟
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다. 🌟
3. 정적 메서드는 인스턴스를 프로퍼티로 참조할 수 없지만 프로토타입 메서드는 인스턴스를 프로퍼티로 참조할 수 있다.

### 클래스의 상속

① 상속에 의한 클래스 확장은 ②프로토타입 기반 상속과는 다른 개념이다.

②는 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 ①은 기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의하는 것이다.

#### extends 키워드

```js
// 수퍼(베이스/부모)클래스
class Base {}

// 서브(파생/자식)클래스
class Derived extends Base {}
```

### 클래스 확장

```js
class Animal {
  constructor(age, weight) {
    this.age = age;
    this.weight = weight;
  }

  eat() {
    return "eat";
  }

  move() {
    return "move";
  }
}

// 상속을 통해 Animal 클래스를 확장한 Bird 클래스
class Bird extends Animal {
  fly() {
    return "fly";
  }
}

const bird = new Bird(1, 5);

console.log(bird); // Bird {age: 1, weight: 5}
console.log(bird instanceof Bird); // true
console.log(bird instanceof Animal); // true (프로토타입 체인으로 얽혀있기 때문에)
console.log(bird instanceof Object); // true (스코프의 최 상위에는 Object가 있다)

console.log(bird.eat()); // eat
console.log(bird.move()); // move
console.log(bird.fly()); // fly
```

#### super 키워드

- super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드다.

```
1. super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.
2. super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.
```

#### super 호출

```js
// 수퍼클래스
class Base {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
}

// 서브클래스
class Derived extends Base {
  constructor(a, b, c) {
    super(a, b); // 수퍼클래스에 정의한 프로퍼티(a,b)를 그대로 사용하겠다는 의미
    this.c = c;
  }
}

const derived = new Derived(1, 2, 3);
console.log(derived); // Derived {a: 1, b: 2, c: 3}
```

#### super 참조

```js
// 수퍼클래스
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

// 서브클래스
class Derived extends Base {
  sayHi() {
    // super.sayHi는 수퍼클래스의 프로토타입 메서드를 가리킨다.
    return `${super.sayHi()}. how are you doing?`;
  }
}

const derived = new Derived("Lee");
console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

#### 추상화

- 추상화는 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것이다

```js
// 수퍼클래스
class Rectangle {
  constructor(width, height) {
    // constructor
    this.width = width;
    this.height = height;
  }

  // 프로토타입 메서드
  getArea() {
    return this.width * this.height;
  }

  toString() {
    return `width = ${this.width}, height = ${this.height}`;
  }
}

// 서브클래스
class ColorRectangle extends Rectangle {
  // extends 키워드를 통해 수퍼클래스를 상속받음
  constructor(width, height, color) {
    super(width, height);
    this.color = color;
  }

  // 메서드 오버라이딩
  toString() {
    return super.toString() + `, color = ${this.color}`;
  }
}

const colorRectangle = new ColorRectangle(2, 4, "red");
console.log(colorRectangle); // ColorRectangle {width: 2, height: 4, color: "red"}

// 상속을 통해 getArea 메서드를 호출
console.log(colorRectangle.getArea()); // 8
// 오버라이딩된 toString 메서드를 호출
console.log(colorRectangle.toString()); // width = 2, height = 4, color = red
```

위 코드의 흐름은 다음과 같다

1. 서브클래스의 super 호출
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 constructor로의 복귀와 this 바인딩
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환

#### 오버라이딩
- 상위(super) 클래스가 가지고 있는 메서드를 하위(sub) 클래스가 재정의하여 사용하는 방식입니다.

#### 오버로딩
- 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다.


## 스프레드 문법

### spread 문법이 뭔가요?
- 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만드는 것으로, 값을 만드는 것이 아니기에 변수에 할당할 수 없다.

<br/>

### 코드 요약

```js
let user = { name: "Mike" };
let info = { age: 30 };
let fe = ["js", "react"];
let lang = ["korean", "english"];

console.log("before user: ", user);

user = {
  ...user,
  ...info,
  skills: [...fe, ...lang],
};

console.log("after user: ", user);

/*
before user:  { name: 'Mike' }
after user:  {
  name: 'Mike',
  age: 30,
  skills: [ 'js', 'react', 'korean', 'english' ]
}
*/
```

<br/>

### 어떤 상황에서 사용할 수 있죠?

스프레드 문법을 사용할 수 있는 대상은 다음과 같이 한정된다.

1. Array
2. String
3. Map
4. Set
5. DOM 컬렉션
6. arguments와 같이 for of 문으로 순회할 수 있는 이터러블

```js
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(..."Hello"); // H e l l o

/* 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다. */
console.log(...{ a: 1, b: 2 });
// TypeError: Found non-callable @@iterator
```

위와 같은 대상에 대해 3가지 상황에서 사용할 수 있다.

1. 함수 호출문의 인수 목록에서 사용하는 경우

2. 배열 리터럴 내부에서 사용하는 경우

3. 객체 리터럴 내부에서 사용하는 경우

<details>

<b>① 함수 호출문의 인수 목록에서 사용하는 경우</b>

- 요소들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야 하는 경우에 유용하다.

```js
const arr = [1, 2, 3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
const max = Math.max(arr); // -> NaN

const max = Math.max(...arr); // -> 3
```

<b>② 배열 리터럴 내부에서 사용하는 경우</b>

스프레드 문법을 배열 리터럴에 사용하면 ES5에서 사용하던 기존의 방식보다 더욱 간결하고 가독성 좋게 표현할 수 있다.

```js
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]

// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]
```

<b>③ 객체 리터럴 내부에서 사용하는 경우</b>

Rest 프로퍼티와 함께 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다.

```js
// 스프레드 프로퍼티
// 객체 복사(얕은 복사)
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2 }
console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }
```

</details>

## 구조 분해 할당

### 구조 분해 할당이 뭔가요?
- 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식입니다.

<br/>

### 구조 분해 할당은 크게 어떤 종류가 있나요?
- 배열의 각 요소를 배열로부터 추출하여 변수에 할당하는 구조분해 할당과 객체의 각 프로퍼티를 객체로부터 추출하여 변수에 할당하는 객체 구조분해 할당이 있습니다.

<details>

<b>① 배열 구조분해 할당</b>

ES6의 배열 구조 분해 할당은 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당합니다.

이때 배열 구조분해 할당의 대상은 이터러블(순회 가능한 상태)여야 하며, 할당 기준은 배열의 인덱스가 됩니다. 즉 순서대로 할당됩니다.

```js
const arr = [1, 2, 3];

const [one, two, three] = arr;
/*
다음과 같습니다

const one = arr[0]
const two = arr[1]
const three = arr[2]

const [one, two, three] = [1,2,3]
*/

console.log(one, two, three); // 1 2 3
```

배열 디스트럭처링 할당은 배열과 같은 이터러블에서 필요한 요소만 추출하여 변수에 할당하고 싶을 때 유용합니다.

```js
const str = "hello-world-2021";

console.log(str.split("-"));

const [one, two, three] = str.split("-");

console.log(one);
console.log(two);
console.log(three);
```

<b>② 객체 구조분해 할당</b>

1. ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.

이때 객체 디스트럭처링 할당의 대상은 객체이어야 하며, 할당 기준은 프로퍼티 키다. (배열처럼 인덱스가 아니다)

즉, 순서는 의미가 없으며 선언된 변수 이름과 프로퍼티가 일치하면 할당된다.

```js
var user = { age: 25, name: "junhee" };

var { age, name } = user;

/*
var { age: age, name: name} = user 와 같은 의미 (프로퍼티 축약 표현)
*/

console.log(age, name); // 25 junhee
```

2. 반드시 프로퍼티 키와 변수 이름이 같을 필요는 없다

```js
var user = { age: 25, name: "junhee" };

var { age: junheeAge, name: junheeName } = user;

/*
위 처럼 새롭게 이름을 지정한 경우 프로퍼티 키로 접근하면 에러가 발생한다
console.log(age, name); // ReferenceError: age is not defined
*/

console.log(junheeAge, junheeName); // 25 junhee
```

3. 객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다 (하지만 넘겨받는 값이 우선이다)

```js
var user = { age: 25 };

var { age, name = "default" } = user;

console.log(age, name); // 25 default
```

4. 객체 디스트럭처링 할당은 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.

```js
case 1

function printTodo(todo) {
  console.log(
    `할일 ${todo.content}은 ${todo.completed ? "완료" : "비완료"} 상태입니다.`
  );
}

case 2

function printTodo({ content, completed }) {
  console.log(`할일 ${content}은 ${completed ? "완료" : "비완료"} 상태입니다.`);
}

printTodo({ id: 1, content: "HTML", completed: true });
```

5. 중첩 객체의 경우는 다음과 같이 사용한다.

```js
const user = {
  name: "junhee",
  age: 25,
  address: {
    zipCode: 14063,
    city: "Anyang",
  },
};

const {
  address: { city },
} = user;

// const city = user.address.city 를 구조 분해 할당하였음

console.log(city); // Anyang
```

</details>

## 브라우저 렌더링 과정

### 브라우저의 렌더링 과정에 대해 설명해보세요
- 클라이언트에서 불러오고 싶은 파일을 서버에 요청 후, 서버에서 응답받은 HTML 파일과 CSS파일을 파싱하여 각각 DOM, CSSOM 트리를 만듭니다. 두 트리를 결합하여 렌더 트리를 만들고 이를 기반으로 각 노드의 레이아웃을 계산합니다. 계산된 값을 이용해 각 노드를 화면에 페인팅합니다.

<br/>

### 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요?
- 렌더링 엔진이 HTML을 파싱하여 DOM을 생성하다 `<script>` 태그를 만나면 DOM 생성을 중단합니다. 그리고 `<script>` 에 정의된 자바스크립트 파일을 서버에 요청 후 로드한 파일이나 `<script>` 태그 내의 자바스크립트 코드를 파싱하기 위해 `자바스크립트 엔진`에 제어권을 넘깁니다. 이후 파싱과 실행이 종료되면 `렌더링 엔진`으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM생성을 재개합니다.

<details>
<summary>📚 단어 정리</summary>

<br/>

<b>① 파싱</b>

파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰 단위로 분해하고, 토큰의 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리를 생성하는 일련의 과정을 말한다.

<b>② 렌더링</b>

렌더링은 HTML, CSS, JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.

<b>③ 리소스</b>

HTTP 요청 대상을 "리소스"라고 부르는데, 그에 대한 본질을 이 이상으로 정의할 수 없습니다.

그것은 문서, 사진 또는 다른 어떤 것이든 될 수 있습니다.

각 리소스는 리소스 식별을 위해 HTTP 전체에서 사용되는 Uniform Resource Identifier (URI)에 의해 식별됩니다.

<b>④ DNS</b>

DNS (Domain Name System)는 인터넷에 연결된 리소스를 위한 계층적이고 분산된 명명 시스템입니다. DNS는 도메인 이름 목록 과 연결된 리소스(예: IP 주소)를 유지 관리 합니다.

</details>

### `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까요?
- 자바스크립트 엔진은 위에서부터 아래로 코드를 실행한다. 만약 `<script>` 태그가 body 태그보다 위에 있다면, 해당 스크립트 내부의 코드를 보면 바디 태그에 포함된 요소인 apple을 동적으로 스타일링을 추가하는 코드입니다. **위 코드는 에러가 발생할 것이다.**

<details>

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="style.css" />
    <script>
      const $apple = document.getElementById("apple");
      $apple.style.color = "red";
    </script>
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </body>
</html>
```

</details>



<details>
<summary>async/ defer</summary>

`async 어트리뷰트`

HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 자바스크립트의 파일의 로드가 완료된 직후 진행되며, 이때 HTML 파싱은 중단된다.

여러 개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않는다.

`defer 어트리뷰트`

async 어트리뷰트와 마찬가지로 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후 진행된다. 따라서 DOM 생성이 완료된 이후 실행되어야 할 자바스크립트에 유용하다.

</details>

## DOM

### DOM이 뭔가요?
- DOM은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API를 제공하는 트리 자료구조다.

### DOM을 구성하는 건 뭐가 있나요?
- DOM은 노드 객체의 계층적인 구조로 구성됩니다. 노드 객체는 총 12개의 종류(노드 타입)가 있으며, 이 중에서 중요한 노드 타입은 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드 등이 있습니다.

## 이벤트

### 마우스 이벤트 타입에는 뭐가 있나요? click 말고 클릭을 대체할 수 있는 이벤트가 있나요?
- dbclick, mousedown, mousemove 등이 있고 mouseup으로 click을 대체할 수 있습니다.

### 그 외에 알고 있는 대표적인 이벤트가 있나요?
- 키보드 이벤트 중에는 keydown, keypress, keyup 등이 있고, 포커스 이벤트에는 focus, blur등이 있습니다.

### 이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나요?

1. 이벤트 핸들러 어트리뷰트 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button onclick="sayHi('Lee')">Click me!</button>
    <script>
      function sayHi(name) {
        console.log(`Hi! ${name}.`);
      }
    </script>
  </body>
</html>
```

2. 이벤트 핸들러 프로퍼티 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩 (익명 함수로 가능)
      $button.onclick = function () {
        console.log("button click");
      };
    </script>
  </body>
</html>
```

3. addEventListener 메서드 방식

```html
<html>
  <body>
    <button>Click me!</button>
    <em></em>

    <script>
      const $button = document.querySelector("button");
      const $em = document.querySelector("em");

      $button.addEventListener("click", function () {
        $em.innerHTML = "Button Cliked 1";
      });
    </script>
  </body>
</html>
```

<br/>

### 이벤트 전파(propagation)에 대해서 알고 있나요?
- DOM 트리상에 존재하는 모든 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됩니다. 이를 이벤트 전파라고 합니다.

### 이벤트 위임(delegation)에 대해서 알고있나요?
- 연속되는 태그에 대해서 공통적으로 이벤트를 줘야할 때 우리가 이벤트 핸들러를 바인딩할 해당 요소의 부모 요소에게 이를 위임하여 이벤트를 진행하는 것입니다.

### e.preventDefault 에 대해 알고 있나요?
- e.preventDefault 메서드는 요소 태그의 기본 동작을 중단합니다.

### e.stopPropagation
- e.stopPropagation 메서드는 이벤트 전파를 중지시키는 메서드입니다.

## 타이머

### 호출 스케쥴링이 무엇인가요?
- 타이머 함수를 사용하여 명시적으로 호출하지 않고 일정 시간이 경기된 이후에 호출되도록 함수 호출을 예약하는 것을 호출 스케쥴링이라고 합니다.

### 타이머 함수에는 어떤 것들이 있나요?
1. setTimeout/ clearTimeout
2. setInterval/ clearInterval

### 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?
- 디바운스와 쓰로틀을 이용하여 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지할 수 있습니다.

### 디바운스에 대해서 알고 있나요?
- 디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 합니다.

### 쓰로틀에 대해서 알고 있나요?
- 쓰로틀(throttle)은 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 합니다.

## 비동기 프로그래밍

### 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요?
- 현재 실행 중인 태스크가 **종료될 때까지 다음에 실행될 태스크가 대기하는 방식** 을 동기(synchronous) 처리 방식이라고 하며 현재 실행 중인 태스크가 **종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식** 을 비동기(asynchronous) 처리라고 한다.

<br/>

### 이벤트 루프와 태스크 큐에 대해서 알고 있나요?
- 예를 들어, HTML 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링하기도 한다. 이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프(event loop)다.

### 다음과 같은 코드에서 이벤트 루프와 태스크 큐가 어떻게 동작하는지 설명해볼 수 있나요?

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 0); // 0초(실제는 4ms) 후에 foo 함수가 호출된다.
bar();
```

1. 실행 컨텍스트에 의해 전역 스코프에 존재하는 함수 (foo, bar)가 평가되어 전역 실행 컨텍스트를 생성합니다

2. 전역 코드 실행 단계에서 위에 상대적으로 위에 존재하는 setTimeout 함수를 호출합니다

- 이때 setTimeout 함수의 실행 컨텍스트가 생성되고 콜스택에 푸시되어 실행 중인 실행 컨텍스트가 됩니다

3. setTimeout 함수가 실행되면서 콜백 함수를 호출 스케줄링 (주어진 시간 0ms)하고 종료되어 콜 스택에서 팝됩니다

- 이때 타이머의 설정과 타이머가 만료되면 콜백 함수(foo)를 태스크 큐에 푸시하는 것은 브라우저의 역할입니다

4. 브라우저가 수행하는 **4.1** 과 자바스크립트 엔진이 수행하는 **4.2** 는 병렬 처리됩니다

   4.1 브라우저는 타이머를 설정하고 타이머의 만료를 기다린다. 이후 타이머가 만료되면 콜백 함수 foo가 태스크 큐에 푸시됩니다

   4.2 bar 함수가 호출되어 bar 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 컨텍스트가 된다. 이후 bar 함수가 종료되어 콜 스택에서 팝된다.

5. 비동기로 진행되는 함수 **① setTimeout/ setInterval ② HTTP 요청 ③ 이벤트 핸들러** 은 브라우저에 의해 태스크 큐로 이동하게 되는데, 동기적으로 실행되는 함수가 모두 실행되고 콜 스택에서 팝된 이후에 태스크 큐에 먼저 들어온 함수부터 차례대로 콜스택에 푸시한다

```js
>>>
bar

foo
```

<br/>

### 마이크로태스크 큐에 대해서 알고 있나요?
- **마이크로태스크 큐** 는 **태스크큐** 와 별도의 큐로 후속 처리 메서드의 콜백 함수가 일시 저장되며, 태스크 큐보다 우선순위가 높다.

### 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요?
- 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.
- 
## Ajax

### Ajax가 뭔가요 어떤 것을 담당하고 있죠?
- Ajax(Asynchronous JavaScript and XML)란 **자바스크립트를 사용하여 ① 브라우저가 ② 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식** 을 말하며, 웹페이지에서 변경할 필요가 있는 부분만 한정적으로 렌더링하는 방식이 가능합니다.

### Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?

1. 변경할 부분을 갱신하는데 필요한 데이터만 서버로부터 전송받기 때문에 불필요한 데이터 통신이 발생하지 않는다.

2. 변경할 필요가 없는 부분은 다시 렌더링하지 않는다. 따라서 화면이 순간적으로 깜박이는 현상이 발생하지 않는다.

3. 클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸 이후 블로킹이 발생하지 않는다.

<br/>

### JSON 이 뭔가요?
- JSON은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷입니다.

### JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나요?
- 객체를 JSON 포맷의 문자열로 변환하는 JSON.stringify()와 JSON 포맷의 문자열을 객체로 변환하는 JSON.parse()가 있습니다.

### Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나요?
- 자바스크립트를 사용하여 HTTP 요청을 전송하려면 **XMLHttpRequest** 객체를 사용합니다

### XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요?
- `fetch` 메서드 또한 `XMLHttpRequest` 처럼 Ajax 통신을 위해 사용됩니다. 하지만 `fetch` 메서드는 **Promise**를 기반으로 구성되어 있어서 더 간편하게 사용할 수 있다는 차이점이 있습니다.

## REST API

### REST API가 뭔가요?
- REST는 **HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고,** REST API는 **REST를 기반으로 서비스 API를 구현한 것을 의미한다.**

<br/>

### REST API의 구성은 어떤 것이 있나요?
- REST API는 **① 자원(resource), ② 행위 (verb), ③ 표현 (representations)** 의 3가지 요소로 구성된다.

<br/>

### REST API를 설계하는데 중요한 것이 있을까요?
- ① URI는 리소스를 표현하는데 집중해야 한다.
- ② 행위에 대한 정의는 HTTP 요청 메서드를 통해 해야 한다.

<br/>

### HTTP 요청 메서드에 대해서 아는대로 얘기해보세요

| HTTP 요청 메서드 | 종류           | 목적                  | 페이로드 |
| :--------------- | :------------- | :-------------------- | :------- |
| GET              | index/retrieve | 모든/특정 리소스 취득 | x        |
| POST             | create         | 리소스 생성           | o        |
| PUT              | replace        | 리소스의 전체 교체    | o        |
| PATCH            | modify         | 리소스 일부 수정      | o        |
| DELETE           | delete         | 모든/특정 리소스 삭제 | x        |

<br/>

### HTTP 상태 코드를 아는대로 말해주세요
- `2XX`
  - 200 : 요청이 성공적으로 보내졌음을 의미         
  - 201 : 요청이 성공적이였으며 새로운 리소스가 생성되었음을 의미
- `4XX`
  - 400 : Bad Request 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미
  - 401 : Unathorized 비인증(Unathorize)된 요청임을 의미                         
  - 403 : Forbidden 콘텐츠에 접근할 권리를 가지고 있지 않음을 의미
  - 404 : Not Found 요청받은 리소스를 찾을 수 없음을 의미                      

- `5XX`
  - 500 : Internal Server Error 서버가 처리 방법을 모르는 상황을 의미

## Promise

### 콜백이란 뭐라고 생각하나요?
- 콜백 함수는 다른 함수의 매개변수로 함수를 전달하고, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 다시 호출되는 것을 의미하는 비동식 방식의 함수입니다.

### 프로미스가 뭔가요?
- 프로미스는 ES6에서 도입된, 콜백 함수의 문제점인 여러 개의 비동기 처리를 해결하기 위한 또 하나의 패턴입니다.

### 프로미스 생성 방법
- Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성한다.

<br/>

### 프로미스의 상태를 나타내는 것은 어떤 것들이 있나요?
- pending : 비동기 처리가 아직 수행되지 않은 상태, <상태 변경 조건> 프로미스가 생성된 직후 기본 상태
- fulfilled : 비동기 처리가 수행된 상태(성공), <상태 변경 조건> resolve 함수 호출
- reject : 비동기 처리가 수행된 상태(실패), <상태 변경 조건> reject 함수

<br/>

### 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요?

- Promise.resolve/ Promise.reject
- Promise.all
- Promise.race
- Promise.allSettled

<br/>

## 제너레이터와 async await

### `제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?`
- ES6에서 도입된 제너레이터(generator)는 코드 블록의 실행을 일시 중지 (블로킹) 했다가 필요한 시점에 재개할 수 있는 특수한 함수다.
- 일반함수와의 차이
  - ① 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
  - ② 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
  - ③ 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.

<br/>

### `제너레이터의 구조`
- 제너레이터는 ① yield 키워드와 ② next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.

<br/>

### `async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠?`
- `async/await`는 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 것입니다.
- 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.

<br/>

### `Promise와 async/await의 차이점 한 줄 요약`
- Promise 를 활용할 시에는 .catch() 문을 통해 에러 핸들링을 해야 하지만, async/await 은 try / catch를 통해 에러를 처리할 수 있다
- async/await 은 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있기 때문에 코드 흐름을 이해 하기 쉽다.

## 에러

### `에러처리를 왜 해야 하나요?`
- 에러가 없는 코드 작성은 불가능하므로 이를 방치한다면 프로그램은 강제 종료될 것이다. 따라서 try catch 문 등을 사용해 발생한 에러를 적절하게 대응하면 프로그래밍이 강제 종료되지 않고 계속해서 코드를 실행시킬 수 있다.

### `자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?`
1. try catch finally
2. Error 객체
3. throw 문

## 모듈

### `모듈이 뭔가요?`
- 모듈(module)이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.

## 내가 뽑은 핵심질문 5개
1. 호이스팅이 뭔가요?
  - js 엔진은 변수나 함수가 어디서 선언이 되던 다른 코드보다 먼저 실행합니다. 런타임 이전에 실행 컨텍스트에 의해 스코프에 등록되고 이를 코드의 최상단에 있는 것처럼 어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅이라고 합니다.
2. 브라우저의 렌더링 과정에 대해 설명해보세요.
  - 클라이언트에서 불러오고 싶은 파일을 서버에 요청 후, 서버에서 응답받은 HTML 파일과 CSS파일을 파싱하여 각각 DOM, CSSOM 트리를 만듭니다. 두 트리를 결합하여 렌더 트리를 만들고 이를 기반으로 각 노드의 레이아웃을 계산합니다. 계산된 값을 이용해 각 노드를 화면에 페인팅합니다. 
3. 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요?
  - 요청을 보낸 후 응답(결과물)을 받아야지만 다음 동작이 이루어지는 방식을 동기(synchronous) 처리 방식이라고 하며 현재 실행 중인 동작이 종료되지 않아도 다음 동작을 곧바로 실행하는 방식 을 비동기(asynchronous) 처리라고 합니다. 비동기방식은 동기보다 복잡하지만 결과가 주어지는 시간을 기다리는 동안 다른 작업을 할 수 있으므로 효율적입니다.
4. 클로저는 무엇인가요? 원리와 왜 사용하는지 설명해주세요.
  - 클로저는 스코프를 이용해서 자신이 선언될 당시의 환경을 기억하는 함수의 현상이며, 해당 값에 대한 접근을 특정함수로 제한함으로써 상태를 안전하게 변경하고 유지할 수 있습니다.
5. GET,POST가 어떻게 다르게 쓰는지 말씀해 주세요.
  - GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용합니다. GET은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없으며, POST는 body 에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재합니다.

## 스터디원이 뽑은 핵심질문
1. REST API에 대해 설명해주세요.
  - REST API는 REST 아키텍처 스타일의 조건을 준수하고 RESTful 웹 서비스와 상호 작용할 수 있도록 하는 API(애플리케이션 프로그래밍 인터페이스)이며, 자원, 행위, 표현의 3가지 요소로 구성됩니다. 
  - 자원이 있는 쪽이 서버고 자원을 요청하는 쪽이 클라이언트인 구조를 가지고 있고, 무상태성을 가지고, 캐싱 기능을 사용 가능하며, 서버를 다중 계층으로 구성할 수 있습니다.
2. Promise가 뭔가요?
  - 프로미스는 ES6에서 도입된, 콜백 함수의 문제점인 여러 개의 비동기 처리를 해결하기 위한 또 하나의 객체로 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다. 
  - 비동기 처리 시점을 명확히 표현하고, 비동기 처리 작업의 수정, 삭제, 추가가 용이하며, 코드의 유지 보수성이 증가한다는 장점들이 있습니다.
  - 프로미스의 처리과정은 대기, 이행, 실패라는 3가지 상태를 갖습니다. 
  - Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성한다.